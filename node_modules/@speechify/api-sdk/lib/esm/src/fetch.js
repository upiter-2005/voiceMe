import packageJson from "../package.json";
/**
 * Error class that represents Speechify API server errors.
 * @property statusCode - The HTTP status code of the error.
 */
export class SpeechifyError extends Error {
    statusCode;
    constructor(message, statusCode) {
        super(message);
        this.statusCode = statusCode;
    }
}
export const queryAPI = async ({ baseUrl, url, token, jsonPayload, options = {}, }) => {
    const headers = new Headers(options.headers);
    options.headers = headers;
    headers.set("Authorization", `Bearer ${token}`);
    headers.set("X-Speechify-SDK", "nodejs");
    headers.set("X-Speechify-SDK-Version", packageJson.version);
    if (jsonPayload) {
        options.body = JSON.stringify(jsonPayload);
    }
    if (!headers.get("Content-Type") && jsonPayload) {
        headers.set("Content-Type", "application/json");
    }
    const fullUrl = new URL(url, baseUrl);
    const response = await fetch(fullUrl.toString(), options);
    if (!response.ok) {
        const error = await response.text();
        throw new SpeechifyError(`Speechify API Error ${response.statusText}: ${error || "Unknown error"}`, response.status);
    }
    return response;
};
export const fetchJSON = async ({ baseUrl, url, token, jsonPayload, options = {}, }) => {
    const response = await queryAPI({
        baseUrl,
        url,
        token,
        jsonPayload,
        options,
    });
    const contentType = response.headers.get("content-type");
    const parseJson = contentType?.includes("application/json");
    if (!parseJson) {
        throw new Error("Response is not JSON");
    }
    if (parseJson) {
        return response.json();
    }
};
export const mapLanguage = (lang) => {
    return {
        locale: lang.locale,
        previewAudio: lang.preview_audio,
    };
};
export const mapModel = (model) => {
    return {
        name: model.name,
        languages: model.languages.map(mapLanguage),
    };
};
export const mapVoice = (voice) => {
    return {
        id: voice.id,
        type: voice.type,
        displayName: voice.display_name,
        models: voice.models.map(mapModel),
        gender: voice.gender,
        avatarImage: voice.avatar_image,
    };
};
export const audioFormatToMime = (format) => {
    switch (format) {
        case "mp3":
            return "audio/mpeg";
        case "wav":
            return "audio/wav";
        case "ogg":
            return "audio/ogg";
        case "aac":
            return "audio/aac";
        default:
            throw new Error(`Unsupported audio format: ${format}`);
    }
};
//# sourceMappingURL=fetch.js.map